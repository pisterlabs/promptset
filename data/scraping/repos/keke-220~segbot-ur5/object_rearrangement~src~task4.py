# -*- coding: utf-8 -*-
"""set_table_gpt_v5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cSqoSc6Gk9KM9p-GwHSIIL5VfZICGW3B

#**Interactive Demo of Setting Dining Table**
<!-- <img src="https://raw.githubusercontent.com/yding25/pic_share/master/set_table.png" height="400" /> -->
<img src="https://raw.githubusercontent.com/yding25/pic_share/master/set_table_basic.png" height="350" />

A human requires a service robot to arrange the dining table. The robot has knowledge only of the utensils required. It must calculate the positioning of these utensils.

**Instructions:**

1) Obtain an [API Key](https://openai.com/blog/openai-api/) for GPT-3

2) Choose the dining table utensils

3) Execute all code cells to determine the utensil positions

4) (Optional) Create a video showcasing a robotic arm picking and placing the selected utensils
"""

#@title Customized parameters{display-mode: "form"}

#@markdown Input an API Key for GPT-3
api_key = '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'  #@param {type:"string"}

#@markdown Hint: If you select 'ChatGPT,' you'll need to manually retrieve the response through a web browser
gpt_model = "text-davinci-003"  #@param ["text-davinci-003", "text-curie-001", "text-babbage-001", "text-ada-001"]

#@markdown Choose the dining table utensils (including foods):

#@markdown Plate & Bowl Category:
has_bread_plate = False  #@param {type:"boolean"}
has_dinner_plate = False  #@param {type:"boolean"}
has_teacup_plate = False  #@param {type:"boolean"}
has_fruit_bowl = True  #@param {type:"boolean"}

#@markdown Fork Category:
has_dinner_fork = False  #@param {type:"boolean"}
has_salad_fork = False  #@param {type:"boolean"}
has_dessert_fork = False  #@param {type:"boolean"}
has_seafood_fork = False  #@param {type:"boolean"}

#@markdown Knife Category:
has_butter_knife = False  #@param {type:"boolean"}
has_dinner_knife = False  #@param {type:"boolean"}
has_fish_knife = False  #@param {type:"boolean"}

#@markdown Spoon Category:
has_soup_spoon = False  #@param {type:"boolean"}
has_dessert_spoon = False  #@param {type:"boolean"}
has_tea_spoon = False  #@param {type:"boolean"}

#@markdown Cup & Glass Category:
has_water_cup = False  #@param {type:"boolean"}
has_wine_glass = False  #@param {type:"boolean"}
has_teacup = True  #@param {type:"boolean"}

#@markdown Food Category:
has_bread = False  #@param {type:"boolean"}
has_strawberry = True  #@param {type:"boolean"}

#@markdown Others:
has_napkin = False  #@param {type:"boolean"}
has_place_mat = False  #@param {type:"boolean"}
has_salt_shaker = False  #@param {type:"boolean"}
has_pepper_shaker = False  #@param {type:"boolean"}
has_teacup_mat = False  #@param {type:"boolean"}
has_teacup_lid = False  #@param {type:"boolean"}

import copy
import gc
import itertools
import json
import math
import os
#@markdown ----
# randomly choose a dining table utensils
import random
import re
import subprocess
import sys
import tempfile
import textwrap
import time
from base64 import b64encode

import matplotlib.pyplot as plt
import numpy as np
import openai
from PIL import Image

import cv2

random_choose = False  #@param {type:"boolean"}
if random_choose:
    num_utensil = "3"  #@param ["3"]
    items = [False] * 24
    for i in range(int(num_utensil)):
        items[i] = True
    random.shuffle(items)
    has_bread_plate, has_dinner_plate, has_fruit_bowl, has_dinner_fork, has_salad_fork, has_dessert_fork, has_seafood_fork, has_butter_knife, has_dinner_knife, has_fish_knife, has_soup_spoon, has_dessert_spoon, has_tea_spoon, has_water_cup, has_wine_glass, has_teacup, has_bread, has_strawberry, has_napkin, has_place_mat, has_salt_shaker, has_pepper_shaker, has_teacup_mat, has_teacup_lid = items

# process the input parameters from users
utensils = [
    {
        "name": "bread plate",
        "has": has_bread_plate
    },
    {
        "name": "butter knife",
        "has": has_butter_knife
    },
    {
        "name": "dinner fork",
        "has": has_dinner_fork
    },
    {
        "name": "soup spoon",
        "has": has_soup_spoon
    },
    {
        "name": "water cup",
        "has": has_water_cup
    },
    {
        "name": "wine glass",
        "has": has_wine_glass
    },
    {
        "name": "napkin",
        "has": has_napkin
    },
    {
        "name": "dinner knife",
        "has": has_dinner_knife
    },
    {
        "name": "dinner plate",
        "has": has_dinner_plate
    },
    {
        "name": "salad fork",
        "has": has_salad_fork
    },
    {
        "name": "dessert fork",
        "has": has_dessert_fork
    },
    {
        "name": "dessert spoon",
        "has": has_dessert_spoon
    },
    {
        "name": "tea spoon",
        "has": has_tea_spoon
    },
    {
        "name": "seafood fork",
        "has": has_seafood_fork
    },
    {
        "name": "fish knife",
        "has": has_fish_knife
    },
    {
        "name": "place mat",
        "has": has_place_mat
    },
    {
        "name": "salt shaker",
        "has": has_salt_shaker
    },
    {
        "name": "pepper shaker",
        "has": has_pepper_shaker
    },
    {
        "name": "bread",
        "has": has_bread
    },  # new
    {
        "name": "teacup mat",
        "has": has_teacup_mat
    },
    {
        "name": "strawberry",
        "has": has_strawberry
    },
    {
        "name": "fruit bowl",
        "has": has_fruit_bowl
    },
    {
        "name": "teacup",
        "has": has_teacup
    },
    {
        "name": "teacup lid",
        "has": has_teacup_lid
    }
]
utensil_name = []  # save utensils' name
for utensil in utensils:
    if utensil["has"]:
        utensil_name.append(utensil["name"])
print('utensil to be placed on a dining table:\n{}'.format(utensil_name))

relationship_name = [
    'above', 'to the right of', 'below', 'to the left of',
    'above and to the right of', 'below and to the right of',
    'below and to the left of', 'above and to the left of', 'on top of',
    'under', 'center'
]
print('\npredefined relationships between two utensils on a table:\n{}'.format(
    relationship_name))

#@title Input utensil size and table information (unit of meter) {display-mode: "form"}

#@markdown Hint: These sizes correspond to the object sizes in the simulator. You can change them to fit your own objects.
'''
utensil size by defalut
'''

#@markdown Plate & Bowl Category:
bread_plate_width_length_height = "0.1, 0.1, 0.03"  #@param {type:"string"}
dinner_plate_width_length_height = "0.16, 0.16, 0.03"  #@param {type:"string"}
fruit_bowl_width_length_height = "0.1, 0.1, 0.07"  #@param {type:"string"}

#@markdown Fork Category:
dinner_fork_width_length_height = "0.2, 0.05, 0.03"  #@param {type:"string"}
salad_fork_width_length_height = "0.2, 0.05, 0.03"  #@param {type:"string"}
dessert_fork_width_length_height = "0.17, 0.05, 0.03"  #@param {type:"string"}
seafood_fork_width_length_height = "0.2, 0.05, 0.03"  #@param {type:"string"}

#@markdown Knife Category:
butter_knife_width_length_height = "0.19, 0.05, 0.03"  #@param {type:"string"}
dinner_knife_width_length_height = "0.2, 0.05, 0.03"  #@param {type:"string"}
fish_knife_width_length_height = "0.22, 0.05, 0.03"  #@param {type:"string"}

#@markdown Spoon Category:
dessert_spoon_width_length_height = "0.17, 0.05, 0.03"  #@param {type:"string"}
tea_spoon_width_length_height = "0.17, 0.05, 0.03"  #@param {type:"string"}

#@markdown Spoon Category:
soup_spoon_width_length_height = "0.2, 0.05, 0.03"  #@param {type:"string"}

#@markdown Cup & Glass Category:
water_cup_width_length_height = "0.05, 0.05, 0.13"  #@param {type:"string"}
wine_glass_width_length_height = "0.07, 0.07, 0.17"  #@param {type:"string"}
teacup_width_length_height = "0.1, 0.06, 0.1"  #@param {type:"string"}

#@markdown Food Category:
bread_width_length_height = "0.08, 0.08, 0.06"  #@param {type:"string"}
strawberry_width_length_height = "0.05, 0.05, 0.05"  #@param {type:"string"}

#@markdown Others:
napkin_width_length_height = "0.1, 0.25, 0.03"  #@param {type:"string"}
place_mat_width_length_height = "0.12, 0.12, 0.03"  #@param {type:"string"}
salt_shaker_width_length_height = "0.06, 0.06, 0.1"  #@param {type:"string"}
pepper_shaker_width_length_height = "0.06, 0.06, 0.1"  #@param {type:"string"}
teacup_mat_width_length_height = "0.12, 0.12, 0.03"  #@param {type:"string"}
teacup_lid_width_length_height = "0.08, 0.08, 0.03"  #@param {type:"string"}

#@markdown Table info {display-mode: "form", vertical-output: true }
boundary_min_x = -0.25  #@param {type:"number"}
boundary_max_x = 0.25  #@param {type:"number"}
boundary_min_y = -0.25  #@param {type:"number"}
boundary_max_y = 0.25  #@param {type:"number"}

table_x, table_y = (boundary_min_x + boundary_max_x) / 2, (boundary_min_y +
                                                           boundary_max_y) / 2
table_width, table_length = abs(boundary_max_x -
                                boundary_min_x), abs(boundary_max_y -
                                                     boundary_min_y)
"""# Setup"""
"""
#@title Import third-party packages {display-mode: "form"}
!pip install -U openai
!pip install pybullet imageio-ffmpeg
!git clone https://github.com/yding25/urdf_models.git
from google.colab import drive
"""

#@title Utils {display-mode: "form"}
openai.api_key = api_key

utensil_size = {}  # process utensil size
pattern = "([0-9]*\.[0-9]*)"
alpha = 1.05
for utensil in utensil_name:
    variable_name = utensil.replace(" ", "_")
    matches = re.findall(pattern, eval(variable_name + "_width_length_height"))
    utensil_size[utensil] = [
        float(matches[0]) * alpha,
        float(matches[1]) * alpha,
        float(matches[2]) * alpha
    ]

utensil_init_pose = {}  # save utensils' inital pose
for utensil in utensils:
    if utensil["has"]:
        # utensil_init_pose[utensil["name"]] = [[1.4, -0.65, 0.65], [0, 0, 0, 1]] # big table
        utensil_init_pose[utensil["name"]] = [[
            1.15, -0.18, 0.65 + utensil_size[utensil["name"]][2]
        ], [0, 0, 0, 1]]


def count_tokens(text):
    return len(text.split())


def fee_tokens(text):
    if gpt_model == "text-davinci-003":
        return round(len(text.split()) / 1000.0 * 0.02, 3)
    elif gpt_model == "text-curie-001":
        return round(len(text.split()) / 1000.0 * 0.002, 3)
    elif gpt_model == "text-babbage-001":
        return round(len(text.split()) / 1000.0 * 0.0005, 3)
    elif gpt_model == "text-ada-001":
        return round(len(text.split()) / 1000.0 * 0.0004, 3)
    elif gpt_model == "ChatGPT":
        return round(len(text.split()) / 1000.0 * 0.0, 3)


def create_prompt_relationship(input, zeroshot=True):
    '''
  @input: a list of several utensils, e.g., ['fork', 'plate']
  @output: a sentence of prompt, e.g., How to place a fork, and a plate on a table?
  '''
    utensils = ''
    for index in range(len(input)):
        if index < len(input) - 1:
            utensils += 'a ' + input[index] + ', '
        else:
            utensils += 'and a ' + input[index] + ' '

    prompt_hint = 'The goal is to arrange a dining table with objects. The spatial relationship between two objects includes only one of the following options: above, to the right of, below, to the left of, above and to the right of, below and to the right of, below and to the left of, above and to the left of, on top of, under, and center.\n\n'
    if zeroshot:
        prompt_example = ''
    else:
        prompt_example = '###\nWhat is a typical way of positioning a water cup and a dinner plate on a table?\n1. Place the dinner plate in the center of the table.\n2. Place the water cup above and to the right of the dinner plate.\n\n###\nWhat is a typical way of positioning a dinner fork and a dinner knife on a table?\n1. Place the dinner fork to the left of the dinner knife.\n\n###\n'
    prompt_question = 'What is a typical way of positioning ' + utensils + 'on a table? '
    prompt_note = 'Note each action should be on a separate line starting with Place. The answer cannot include other objects.'
    return prompt_hint + prompt_example + prompt_question + prompt_note


def create_prompt_distance(input):
    '''
  @input: object A, object B, spatial relationship, e.g., ['bread_plate', 'dessert fork']
  @output: a sentence of prompt
  '''
    prompt_hint = 'a ' + input[0] + ' is placed ' + input[2] + ' a ' + input[
        1] + '. '
    if input[2] == 'above' or input[2] == 'to the right of' or input[
            2] == 'below' or input[2] == 'to the left of' or input[
                2] == 'above':
        prompt_question = 'how many centimeters ' + input[2] + ' the ' + input[
            1] + ' should the ' + input[0] + ' be placed' + '?'
    else:
        prompt_question = 'how many centimeters ' + input[2] + ' the ' + item[
            1] + ' should the ' + item[0] + ' be placed' + '? '
    return prompt_hint + prompt_question


def extract_object_relationship(commonsense, utensil_name, relationship_name):
    '''
  @commonsense: a sentence, e.g., 'place the plate in the center of the table.'; utensil_name and relationship_name are fixed
  @output: a sentence, e.g., 'object a: plate, object b: table, relationship: center'
  '''
    utensil_name = utensil_name + ['table'
                                   ]  # table is not in utensil_name by default
    # extract object A and B in commonsense
    objects = []
    for item in utensil_name:
        matches = re.finditer(item, commonsense)
        for match in matches:
            objects.append((item, match.start()))
    objects.sort(key=lambda x: x[1])

    # corner case: 'bread' and 'bread plate'; 'teacup' and 'teacup lid'
    # print('objects (before):{}'.format(objects))
    def check_same_number(list_a):
        temp = []
        for i in range(len(list_a)):
            for j in range(i + 1, len(list_a)):
                if list_a[i][1] == list_a[j][1]:
                    if len(list_a[i][0]) < len(list_a[j][0]):
                        temp.append(i)
                    else:
                        temp.append(j)
        list_a_temp = []
        for i in range(len(list_a)):
            if i not in temp:
                list_a_temp.append(list_a[i])
        return list_a_temp

    objects = check_same_number(objects)
    # print('objects (after):{}'.format(objects))

    if len(objects) == 2:  # commonsense has two objects
        object_A = objects[0][0]
        object_B = objects[1][0]
    elif len(objects) != 2:
        print("!Error: Expected 2 unique objects but found {}".format(objects))
        print("commonsense: {}".format(commonsense))
        sys.exit()

    # extract "relationship" from commonsense
    relationship = []
    for item in relationship_name:
        if re.search(item, commonsense):
            relationship.append(item)

    if len(relationship) > 1:  # processs corner cases
        if 'on' in relationship:
            relationship.remove('on')
        if 'above' in relationship:
            relationship.remove('above')
        if 'below' in relationship:
            relationship.remove('below')
        if 'to the left of' in relationship:
            relationship.remove('to the left of')
        if 'to the right of' in relationship:
            relationship.remove('to the right of')
    if len(relationship) != 1:
        print("!Error: Expected 1 relationship but found {}".format(
            len(relationship)))
        print("commonsense: {}".format(commonsense))
        sys.exit()

    return object_A, object_B, relationship[0]


def opposite_direction(relationship):
    if 'above' == relationship:
        return 'below'
    elif 'below' == relationship:
        return 'above'
    elif 'to the left of' == relationship:
        return 'to the right of'
    elif 'to the right of' == relationship:
        return 'to the left of'
    elif 'above and to the right of' == relationship:
        return 'below and to the left of'
    elif 'below and to the right of' == relationship:
        return 'above and to the left of'
    elif 'below and to the left of' == relationship:
        return 'above and to the right of'
    elif 'above and to the left of' == relationship:
        return 'below and to the right of'
    elif 'on top of' == relationship:
        return 'under'
    else:
        print('!Error: Unexpected relationship: {}'.format(relationship))
        sys.exit()
        return None


def extract_distance(commonsense_concrete, type):
    '''
  @commonsense_concrete: a sentence, e.g., 'the distance between the bread plate and the plate will depend on the size of the plates. generally, the distance between the two plates should be around 10-15 centimeters.'
  @output: a distance value, e.g., 14
  '''
    res = re.findall(r'\d+', commonsense_concrete)
    if type == 'type1':  #'above' or 'below'
        if len(res) not in (1, 2):
            print("!Warning: Expected 1-2 values but found {}".format(
                len(res)))
            return 5, 0
        if len(res) == 1:
            return int(res[0]), 0
        # return random.randint(int(res[0]), int(res[1])), 0
        return (int(res[0]) + int(res[1])) / 2.0, 0
    if type == 'type2':  # 'to the right of' or 'to the left of'
        if len(res) not in (1, 2):
            print("!Warning: Expected 1-2 values but found {}".format(
                len(res)))
            return 0, 5
        if len(res) == 1:
            return 0, int(res[0])
        # return 0, random.randint(int(res[0]), int(res[1]))
        return 0, (int(res[0]) + int(res[1])) / 2.0
    if type == 'type3':  # 'above and to the right of' or 'below and to the right of' or 'below and to the left of' or 'above and to the left of':
        if len(res) not in (1, 2):
            print("!Warning: Expected 1-2 values but found {}".format(
                len(res)))
            return 3.5, 3.5
        if len(res) == 1:
            return int(math.sqrt(int(res[0]))), int(math.sqrt(int(res[0])))
        return int(math.sqrt(random.randint(int(res[0]), int(res[1])))), int(
            math.sqrt(random.randint(int(res[0]), int(res[1]))))


def llm(prompt):  # call LLM
    sampling_params = {
        "n": 1,
        "max_tokens": 512,
        "temperature": 0.0,
        "top_p": 1,
        "logprobs": 1,
        "presence_penalty": 0,
        "frequency_penalty": 0,
        "stop": ['\\n']
    }
    raw_response = openai.Completion.create(engine=gpt_model,
                                            prompt=prompt,
                                            **sampling_params)
    responses = [
        raw_response['choices'][i]['text'] for i in range(sampling_params['n'])
    ]
    mean_probs = [
        math.exp(
            np.mean(raw_response['choices'][i]['logprobs']['token_logprobs']))
        for i in range(sampling_params['n'])
    ]
    responses = [sample.strip().lower() for sample in responses]
    return responses[0]


def relationship_objectAB(object_A, object_B, pose_A, pose_B, relationship,
                          distance):
    '''
  assume object_B is known
  compute the object_A pose accprding to object_B pose, relationship and distance
  '''
    # print('Debug:relationship: {}'.format(relationship))
    pose_A.update(pose_B)
    # above, to the right of, below, to the left of, above and to the right of, below and to the right of, below and to the left of, above and to the left of, on, under, and center
    if 'above' == relationship:
        pose_A['x'] = pose_B['x'] + float(distance[0]) / 100. + utensil_size[
            object_A][0] * 0.5 + utensil_size[object_B][0] * 0.5
    elif 'to the right of' == relationship:
        # print('!Debug: objectA:{}, objectB:{}, pose_Ay:{}, pose_By:{}, float(distance[1]):{}., utensil_size[object_A][1]:{}, utensil_size[object_B][1]:{}'.format(object_A, object_B, pose_A['y'], pose_B['y'], float(distance[1]), utensil_size[object_A][1], utensil_size[object_B][1]))
        pose_A['y'] = pose_B['y'] - float(distance[1]) / 100. - utensil_size[
            object_A][1] * 0.5 - utensil_size[object_B][1] * 0.5
    elif 'below' == relationship:
        pose_A['x'] = pose_B['x'] - float(distance[0]) / 100. - utensil_size[
            object_A][0] * 0.5 - utensil_size[object_B][0] * 0.5
    elif 'to the left of' == relationship:
        pose_A['y'] = pose_B['y'] + float(distance[1]) / 100. + utensil_size[
            object_A][1] * 0.5 + utensil_size[object_B][1] * 0.5
    elif 'above and to the right of' == relationship:
        # distance of shape centers
        pose_A['x'] = pose_B['x'] + float(distance[0]) / 100.
        pose_A['y'] = pose_B['y'] - float(distance[1]) / 100. - utensil_size[
            object_A][1] * 0.5 - utensil_size[object_B][1] * 0.5
    elif 'below and to the right of' == relationship:
        # distance of shape centers
        pose_A['x'] = pose_B['x'] - float(distance[0]) / 100.
        pose_A['y'] = pose_B['y'] - float(distance[1]) / 100. - utensil_size[
            object_A][1] * 0.5 - utensil_size[object_B][1] * 0.5
    elif 'below and to the left of' == relationship:
        # distance of shape centers
        pose_A['x'] = pose_B['x'] - float(distance[0]) / 100.
        pose_A['y'] = pose_B['y'] + float(distance[1]) / 100. + utensil_size[
            object_A][1] * 0.5 + utensil_size[object_B][1] * 0.5
    elif 'above and to the left of' == relationship:
        # distance of shape centers
        pose_A['x'] = pose_B['x'] + float(distance[0]) / 100.
        pose_A['y'] = pose_B['y'] + float(distance[1]) / 100. + utensil_size[
            object_A][1] * 0.5 + utensil_size[object_B][1] * 0.5
    elif 'on top of' == relationship:
        pose_A['z'] = pose_B['z'] + 0.1
    elif 'under' == relationship:
        pose_A['z'] = pose_B['z'] - 0.1
    elif 'center' == relationship:
        pass
    # print('\noutput:\n pose_A:{}, pose_B:{}, relationship:{}, distance:{}'.format(pose_A, pose_B, relationship, distance))
    # print('-'*40)


def sortdict(utensil_name_sequenced):
    # input: {'dinner knife': 0.75, 'plate': 0.65, 'fork': 0.65, 'spoon': 0.65}
    # output: {'plate': 0.65, 'fork': 0.65, 'spoon': 0.65, 'dinner knife': 0.75}
    return sorted(utensil_name_sequenced,
                  key=lambda x: utensil_name_sequenced[x])


def del_list(full_list, sub_list):
    new_full_list = [
        itemA for itemA in full_list
        if not any(itemA == itemB for itemB in sub_list)
    ]
    return new_full_list


def is_collision(x1, y1, width1, length1, x2, y2, width2, length2):
    # print('y1 - y2: {}, (length1 + length2) / 2.0: {}'.format(abs(y1 - y2), (length1 + length2) / 2.0))
    # print('x1 - x2: {}, (width1 + width2) / 2.0: {}'.format(abs(x1 - x2), (width1 + width2) / 2.0))
    if abs(x1 - x2) > (width1 + width2) / 2.0 or abs(
            y1 - y2) > (length1 + length2) / 2.0:
        return False
    else:
        return True


def get_combination(input_list):
    result = []
    for i in range(len(input_list)):
        for j in range(i + 1, len(input_list)):
            result.append((input_list[i], input_list[j]))
    return result


def get_maxkey(data):
    result = {}
    for key, value in data.items():
        result[key] = value[0] * value[1]
    max_key = max(result, key=result.get)
    # print("The item with the largest value is:", max_key)
    return max_key


def process_response(response_commonsense, zero_shot):
    # cornor case 1: xxx, xxx, xxx
    if zero_shot:
        response_commonsense = '\n'.join([
            line for line in response_commonsense.split(', ') if line.strip()
        ])  # split a long sentence into multiple lines

    # cornor case 2: plate, center --> plate, center of table
    if zero_shot:
        if 'table' not in response_commonsense and 'center' in response_commonsense:
            response_commonsense = response_commonsense.replace(
                "center", "center of the table")

    # cornor case 3: both should be placed in the center of the table. --> delete this sentece
    if zero_shot:
        lines = response_commonsense.split('\n')
        filtered_lines = [
            line for line in lines
            if not ('table' in line and not any(item in line
                                                for item in utensil_name))
        ]
        response_commonsense = '\n'.join(filtered_lines)

    # cornor case 4: if both table and center are not in sentence, assign an object in the center of object
    if 'table' not in response_commonsense and 'center' not in response_commonsense:
        response_commonsense = response_commonsense + '\n' + get_maxkey(
            utensil_size) + ' center of the table'

    # cornor case 5: remove '1.', '2.', ...
    response_commonsense = response_commonsense.split('\n')
    for index in range(len(response_commonsense)):
        response_commonsense[index] = re.sub(r'\d+\. ', '',
                                             response_commonsense[index])

    # cornor case 6: plate -> dinner plate
    for index in range(len(response_commonsense)):
        if 'plate' in response_commonsense[
                index] and 'dinner' not in response_commonsense[
                    index] and 'bread' not in response_commonsense[index]:
            response_commonsense[index] = response_commonsense[index].replace(
                "plate", "dinner plate")

    # cornor case 7: plate -> dinner plate
    for index in range(len(response_commonsense)):
        if 'plate' in response_commonsense[
                index] and 'bread' not in response_commonsense[
                    index] and 'teacup' not in response_commonsense[index]:
            response_commonsense[index] = response_commonsense[index].replace(
                "plate", "dinner plate")

    return response_commonsense


def create_prompt_augmented_commonsense(isolated_utensil, remaining_utensil):
    prompt_hint = 'The task is to set up a dining table. The relationship between two objects can only contain the following planar relationships: above, to the right of, below, to the left of, above and to the right of, below and to the right of, below and to the left of, above and to the left of, on top of, under, and center.\n\n '
    prompt_question = 'Where should a {} be placed in relation to a {}?'.format(
        remaining_utensil, isolated_utensil)
    return prompt_hint + prompt_question


def overlap(u1_x, u1_y, u1_width, u1_length, u2_x, u2_y, u2_width, u2_length):
    left1 = u1_x - u1_width / 2
    right1 = u1_x + u1_width / 2
    top1 = u1_y + u1_length / 2
    bottom1 = u1_y - u1_length / 2

    left2 = u2_x - u2_width / 2
    right2 = u2_x + u2_width / 2
    top2 = u2_y + u2_length / 2
    bottom2 = u2_y - u2_length / 2

    if left1 > right2 or right1 < left2 or top1 < bottom2 or bottom1 > top2:
        return False
    else:
        return True


def is_inside(u1_x, u1_y, u1_width, u1_length, table_x, table_y, table_width,
              table_length):
    left1 = u1_x - u1_width / 2
    right1 = u1_x + u1_width / 2
    top1 = u1_y + u1_length / 2
    bottom1 = u1_y - u1_length / 2

    left2 = table_x - table_width / 2
    right2 = table_x + table_width / 2
    top2 = table_y + table_length / 2
    bottom2 = table_y - table_length / 2

    if left1 > left2 and right1 < right2 and top1 < top2 and bottom1 > bottom2:
        return True
    else:
        return False


def satisfy_relation(u_x, u_y, anchor_x, anchor_y, relation):
    # above, to the right of, below, to the left of, above and to the right of, below and to the right of, below and to the left of, above and to the left of, on top of, under, and center
    if relation == 'above':
        if u_x > anchor_x and u_y == anchor_y:
            return True
        else:
            return False
    if relation == 'to the right of':
        if u_x == anchor_x and u_y < anchor_y:
            return True
        else:
            return False
    if relation == 'below':
        if u_x < anchor_x and u_y == anchor_y:
            return True
        else:
            return False
    if relation == 'to the left of':
        if u_x == anchor_x and u_y > anchor_y:
            return True
        else:
            return False
    if relation == 'above and to the right of':
        if u_x > anchor_x and u_y < anchor_y:
            return True
        else:
            return False
    if relation == 'below and to the right of':
        if u_x < anchor_x and u_y < anchor_y:
            return True
        else:
            return False
    if relation == 'above and to the left of':
        if u_x > anchor_x and u_y > anchor_y:
            return True
        else:
            return False
    if relation == 'below and to the left of':
        if u_x < anchor_x and u_y > anchor_y:
            return True
        else:
            return False
    if relation == 'on top of':
        if u_x == anchor_x and u_y == anchor_y:
            return True
        else:
            return False
    if relation == 'under':
        if u_x == anchor_x and u_y == anchor_y:
            return True
        else:
            return False
    if relation == '':
        return True


def plot_random_points_in_ellipse(x, y, a, b, sigma):
    M = 100
    # Generate random points within an ellipse centered at (x, y)
    theta = 2 * np.pi * np.random.rand(M)
    r = sigma * np.random.randn(M) + np.sqrt(np.random.rand(M))
    x_ellipse = x + a * r * np.cos(theta)
    y_ellipse = y + b * r * np.sin(theta)

    # Combine the x and y arrays into one array
    # points = np.column_stack((x_ellipse, y_ellipse))
    points = [list(item) for item in itertools.product(x_ellipse, y_ellipse)]

    # Plot the points
    # fig, ax = plt.subplots()
    # ax.scatter(x_ellipse, y_ellipse)
    # ax.set_aspect('equal')
    # plt.show()
    return points


"""# Utilize LLM to calculate utensil positions"""

#@title Get spatial relationship {display-mode: "form"}

#@markdown Hint: The authors recommend using Zero-shot, but in the event of any bugs, switching to Few-shot is suggested as an alternative.
zero_shot = True  #@param {type:"boolean"}

#@markdown Hint: If you select 'ChatGPT,' you'll need to manually retrieve the response through a web browser, and input each line sperately.
chatgpt = False  #@param {type:"boolean"}

# get raw response from LLM
prompt = create_prompt_relationship(utensil_name, zero_shot)
print('-' * 20 + '\nFull prompt (including {} tokens, cost {}$):\n{}\n'.format(
    count_tokens(prompt), fee_tokens(prompt), textwrap.fill(prompt, width=150))
      + '-' * 20)
if not chatgpt:
    response_commonsense = llm(prompt)
else:
    response_from_ChatGPT = input("Please enter response from ChatGPT: ")
    while True:
        response_from_ChatGPT_temp = input(
            "Please enter response from ChatGPT: ")
        if response_from_ChatGPT_temp == 'done':
            break
        response_from_ChatGPT = response_from_ChatGPT + '\n' + response_from_ChatGPT_temp
    response_commonsense = response_from_ChatGPT
print('\nLLM\'s response (raw):\n{}'.format(response_commonsense))

# process raw response
response_commonsense = process_response(response_commonsense, zero_shot)
print('\nLLM\'s response (processed):\n{}'.format(response_commonsense))

# get spatial relationship of utensils
utensils_positioning_abstract = []
for commonsense in response_commonsense:  # extract relationship
    object_A, object_B, relationship_A_B = extract_object_relationship(
        commonsense, utensil_name, relationship_name)
    utensils_positioning_abstract.append(
        [object_A, object_B, relationship_A_B])

print('\nspatial relationship of utensils:')
for item in utensils_positioning_abstract:
    print('{}'.format(item))

#@title Get deterministic physical distances {display-mode: "form", vertical-output: true }
utensils_positioning_concrete = []
for item in utensils_positioning_abstract:
    # print('item: {}'.format(item))
    if 'center' == item[2] or 'on top of' == item[2] or 'under' == item[2]:
        utensils_positioning_concrete.append([str(0), str(0)])
    else:
        prompt = create_prompt_distance(item)
        print('-' * 20 +
              '\nFull prompt (including {} tokens, cost {}$):\n{}\n'.format(
                  count_tokens(prompt), fee_tokens(prompt),
                  textwrap.fill(prompt, width=150)) + '-' * 20)
        response_commonsense_concrete = llm(prompt)
        print('LLM\'s response:\n{}'.format(response_commonsense_concrete))
        if 'top' == item[2] or 'below' == item[2]:
            distance1, distance2 = extract_distance(
                response_commonsense_concrete, 'type1')
        elif 'to the right of' == item[2] or 'to the left of' == item[2]:
            distance1, distance2 = extract_distance(
                response_commonsense_concrete, 'type2')
        elif 'above and to the right of' or 'below and to the right of' or 'below and to the left of' or 'above and to the left of':
            distance1, distance2 = extract_distance(
                response_commonsense_concrete, 'type3')
        else:
            print('!Error: Unexpected relationship type: {}'.format(item[2]))
        utensils_positioning_concrete.append([str(distance1), str(distance2)])
print('\ndistance (in centimeter) between two utensils:\n{}'.format(
    utensils_positioning_concrete))

#@title Get utensil position{display-mode: "form"}
utensils_positioning = []
for index in range(len(utensils_positioning_abstract)):
    item = utensils_positioning_abstract[index] + [
        utensils_positioning_concrete[index]
    ]
    utensils_positioning.append(item)

print('positioning of utensils:')
for item in utensils_positioning:
    print('{}'.format(item))

#@title Calculate coordinate using table's shape center as a reference. {display-mode: "form"}
'''
we ground positioning of utensils according to
1, distance in utensils_positioning
2, size of utensil
'''
utensil_goal_pose = {
    'table': {
        'x': table_x,
        'y': table_y,
        'z': 0.65
    }
}  # intialize utensil's goal pose
for item in utensil_name:
    utensil_goal_pose[item] = {
        'x': utensil_init_pose[item][0][0],
        'y': utensil_init_pose[item][0][1],
        'z': utensil_init_pose[item][0][2]
    }

utensils_positioning_cp = copy.deepcopy(
    utensils_positioning)  # copy utensils_positioning

anchor = 'table'
item_processed = []  # record items that have been processed
anchor_list = []  # save anchors
for item in utensils_positioning_cp:
    if anchor in item:
        if item.index(anchor) == 1:
            utensil = item[0]
            anchor_list.append(utensil)  # save next anchors
            item_processed.append(item)
            relationship_objectAB(utensil, anchor, utensil_goal_pose[utensil],
                                  utensil_goal_pose[anchor], item[2],
                                  item[3])  # compute utensil's goal pose
        else:
            print('!Error: Table is not world anchor by default')
            sys.exit()
if len(anchor_list) != 1:
    print(
        '!Error: Unexpected number of items that have relationship with table')
    sys.exit()
anchor = anchor_list[0]  # set next anchor
if item_processed:
    utensils_positioning_cp = del_list(
        utensils_positioning_cp,
        item_processed)  # remove items that have been processed
else:
    print('!Error: No processed item')
    sys.exit()

if utensils_positioning_cp:
    counter = 0  # count how many items have relationship with anchor
    item_processed = []  # record items that have been processed
    for item in utensils_positioning_cp:
        # print('item: {}'.format(item))
        if anchor in item and item.index(anchor) == 1:
            counter += 1
            item_processed.append(item)
            utensil = item[0]
            anchor_list.append(utensil)  # save next anchors
            # print('utensil:{}, anchor:{}, utensil_goal_pose[utensil]:{}, utensil_goal_pose[anchor]:{}, item[2]:{}, item[3]:{}'.format(utensil, anchor, utensil_goal_pose[utensil], utensil_goal_pose[anchor], item[2], item[3]))
            # print('(before)utensil_goal_pose:{}'.format(utensil_goal_pose))
            relationship_objectAB(utensil, anchor, utensil_goal_pose[utensil],
                                  utensil_goal_pose[anchor], item[2], item[3])
            # print('(after)utensil_goal_pose:{}'.format(utensil_goal_pose))
        elif anchor in item and item.index(anchor) == 0:
            counter += 1
            item_processed.append(item)
            utensil = item[1]
            anchor_list.append(utensil)  # save next anchors
            # opposite direction
            temp_relationship = opposite_direction(item[2])
            # print('temp_relationship: {}'.format(temp_relationship))
            # print('utensil:{}, anchor:{}, utensil_goal_pose[utensil]:{}, utensil_goal_pose[anchor]:{}, opposite_direction:{}, item[3]:{}'.format(utensil, anchor, utensil_goal_pose[utensil], utensil_goal_pose[anchor], temp_relationship, item[3]))
            # print('(before)utensil_goal_pose:{}'.format(utensil_goal_pose))
            relationship_objectAB(utensil, anchor, utensil_goal_pose[utensil],
                                  utensil_goal_pose[anchor], temp_relationship,
                                  item[3])
            # print('(after)utensil_goal_pose:{}'.format(utensil_goal_pose))
    if counter == 0:
        print(
            '!Error: Cannot find items that have relationship with {}'.format(
                anchor))
        sys.exit()
    utensils_positioning_cp = del_list(
        utensils_positioning_cp,
        item_processed)  # remove items that have been processed

interrupt_signal = 0
while utensils_positioning_cp and interrupt_signal <= 100:
    interrupt_signal += 1
    anchor_list_cp = copy.deepcopy(anchor_list)  # copy anchor_list
    for anchor in anchor_list_cp:
        item_processed = []  # record items that have been processed
        for item in utensils_positioning_cp:
            if anchor in item and item.index(anchor) == 1:
                item_processed.append(item)
                utensil = item[0]
                anchor_list.append(utensil)
                relationship_objectAB(utensil, anchor,
                                      utensil_goal_pose[utensil],
                                      utensil_goal_pose[anchor], item[2],
                                      item[3])
        utensils_positioning_cp = del_list(
            utensils_positioning_cp,
            item_processed)  # remove items that have been processed

if interrupt_signal == 100:
    print('!Error: Something wrong')
    sys.exit()

# sequence utensil_name according to "z"
utensil_name = sorted(utensil_name, key=lambda x: utensil_goal_pose[x]['z'])

# print final results
print('positioning result (unit is meter):')
print('world anchor: table, its pose: {}'.format(utensil_goal_pose['table']))
for item in utensil_name:
    print('utensil: {}, its pose: {}'.format(item, utensil_goal_pose[item]))

#@title Get stochastic distances (only process three objects) {display-mode: "form", vertical-output: true }
counter = 0
points_utensil1 = []
points_utensil2 = []
points_utensil3 = []
relationship_seq = []
for item in utensil_name:
    x_center = utensil_goal_pose[item]['x']
    y_center = utensil_goal_pose[item]['y']
    print('utensil_name: {}, x_center: {:3f}, y_center: {:3}'.format(
        item, x_center, y_center))
    for item_temp in utensils_positioning:
        utensil_temp = item_temp[0]
        relationship_temp = item_temp[2]
        if utensil_temp == item:
            relationship_seq.append(relationship_temp)
            break
        else:
            continue
    # print('utensil_name:{}, relationship_temp:{}'.format(utensil_temp, relationship_temp))
    counter += 1
    points = []
    if relationship_temp == 'above' or relationship_temp == 'below':
        points = plot_random_points_in_ellipse(x_center, y_center, 0.01, 0.03,
                                               1.0)
    elif relationship_temp == 'to the right of' or relationship_temp == 'to the left of':
        points = plot_random_points_in_ellipse(x_center, y_center, 0.03, 0.01,
                                               1.0)
    elif relationship_temp == 'above and to the right of' or relationship_temp == 'below and to the right of' or relationship_temp == 'below and to the left of' or relationship_temp == 'above and to the left of':
        points = plot_random_points_in_ellipse(x_center, y_center, 0.03, 0.03,
                                               1.0)
    elif relationship_temp == 'center':
        points = plot_random_points_in_ellipse(x_center, y_center, 0.03, 0.03,
                                               1.0)
    elif relationship_temp == 'on top of' or relationship_temp == 'under':
        points = plot_random_points_in_ellipse(x_center, y_center, 0.0001,
                                               0.0001, 10.0)
    else:
        print('!Error: Unexpected relationship: {}'.format(relationship_temp))
        sys.exit()
    if counter == 1:
        points_utensil1 = points
    elif counter == 2:
        points_utensil2 = points
    elif counter == 3:
        points_utensil3 = points
    else:
        print('!Error: Unexpected counter: {}'.format(counter))
        sys.exit()

candidates_pair = []

u1_width, u1_length, u1_height = utensil_size[utensil_name[0]]
u2_width, u2_length, u2_height = utensil_size[utensil_name[1]]
u3_width, u3_length, u3_height = utensil_size[utensil_name[2]]

utensil_relationships = {
    'u1_u2': '',
    'u2_u1': '',
    'u1_u3': '',
    'u3_u1': '',
    'u2_u3': '',
    'u3_u2': ''
}
for item in utensils_positioning_abstract:
    if 'table' not in item:
        utensil_relationships['u{}_u{}'.format(
            utensil_name.index(item[0]) + 1,
            utensil_name.index(item[1]) + 1)] = item[2]
print('utensil_name:{}'.format(utensil_name))
print('utensil_relationships:{}'.format(utensil_relationships))

#  on top of and under: do not sample
for item in utensil_relationships:
    if 'on top of' in utensil_relationships[
            item] or 'under' in utensil_relationships[item]:
        print('item that has on top of and under:{}'.format(item))
        numbers = item.split("_")
        number_1 = int(numbers[0][1:])
        number_2 = int(numbers[1][1:])
        if number_1 == 1:
            if number_2 == 2:
                points_utensil1 = points_utensil2
            elif number_2 == 3:
                points_utensil1 = points_utensil3
        elif number_1 == 2:
            if number_2 == 1:
                points_utensil2 = points_utensil1
            elif number_2 == 3:
                points_utensil2 = points_utensil3
        elif number_1 == 3:
            if number_2 == 1:
                points_utensil3 = points_utensil1
            elif number_2 == 2:
                points_utensil3 = points_utensil2
        break

# points_set = np.column_stack((points_utensil1, points_utensil2, points_utensil3))
points_set = [
    list(i) for i in zip(points_utensil1, points_utensil2, points_utensil3)
]
print('number of items in points_set: {}'.format(len(points_set)))

counter = {
    'signal_1': 0,
    'signal_2': 0,
    'signal_3': 0,
    'signal_7': 0,
    'signal_8': 0,
    'signal_9': 0
}
for item in points_set:
    u1_x, u1_y = item[0][0], item[0][1]
    u2_x, u2_y = item[1][0], item[1][1]
    u3_x, u3_y = item[2][0], item[2][1]
    # print('u1_x:{}, u1_y:{}, u2_x:{}, u2_y:{}, u3_x:{}, u3_y:{}'.format(u1_x, u1_y, u2_x, u2_y, u3_x, u3_y))

    signal_1, signal_2, signal_3, signal_7, signal_8, signal_9 = False, False, False, False, False, False

    # hard constraint 1: no collision between two utensils
    if not overlap(u1_x, u1_y, u1_width, u1_length, u2_x, u2_y, u2_width,
                   u2_length) or utensil_relationships[
                       'u1_u2'] == 'on top of' or utensil_relationships[
                           'u2_u1'] == 'on top of' or utensil_relationships[
                               'u1_u2'] == 'under' or utensil_relationships[
                                   'u1_u2'] == 'under':
        signal_1 = True
        counter['signal_1'] += 1
    if not overlap(u1_x, u1_y, u1_width, u1_length, u3_x, u3_y, u3_width,
                   u3_length) or utensil_relationships[
                       'u1_u3'] == 'on top of' or utensil_relationships[
                           'u3_u1'] == 'on top of' or utensil_relationships[
                               'u1_u3'] == 'under' or utensil_relationships[
                                   'u1_u3'] == 'under':
        signal_2 = True
        counter['signal_2'] += 1
    if not overlap(u2_x, u2_y, u2_width, u2_length, u3_x, u3_y, u3_width,
                   u3_length) or utensil_relationships[
                       'u2_u3'] == 'on top of' or utensil_relationships[
                           'u3_u2'] == 'on top of' or utensil_relationships[
                               'u2_u3'] == 'under' or utensil_relationships[
                                   'u2_u3'] == 'under':
        signal_3 = True
        counter['signal_3'] += 1

    # hard constraint 2: cannot be outside the table
    if is_inside(u1_x, u1_y, u1_width, u1_length, table_x, table_y,
                 table_width, table_length):
        signal_7 = True
        counter['signal_7'] += 1
    if is_inside(u2_x, u2_y, u2_width, u2_length, table_x, table_y,
                 table_width, table_length):
        signal_8 = True
        counter['signal_8'] += 1
    if is_inside(u3_x, u3_y, u3_width, u3_length, table_x, table_y,
                 table_width, table_length):
        signal_9 = True
        counter['signal_9'] += 1

    if signal_1 and signal_2 and signal_3 and signal_7 and signal_8 and signal_9:
        candidates_pair.append([[u1_x, u1_y], [u2_x, u2_y], [u3_x, u3_y]])

# print ()
# print('counter:{}'.format(counter))
if len(candidates_pair) > 25:
    candidates_pair = random.sample(candidates_pair, 25)

print('number of feasible settings:{}'.format(len(candidates_pair)))
with open("gpt3_log/pose_objects.json", 'w+') as outfile:
    json.dump(candidates_pair, outfile)
with open("gpt3_log/objects.json", 'w+') as outfile:
    json.dump(utensil_name, outfile)
with open("gpt3_log/abstract_pose.json", 'w+') as outfile:
    json.dump(utensil_relationships, outfile)
